# 4장 데이터베이스
## 4.5 인덱스

### 4.5.1 인덱스의 필요성
- 인덱스: 데이터를 빠르게 찾을 수 있는 하나의 장치

### 4.5.2 B-트리
- 인덱스는 보통 B-트리 자료구조로 이루어짐
- 루트 노드, 리프 노드, 브랜치 노드로 나뉨
- 효율적인 단계를 처져 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 트리 깊이의 대수확장성 -> 효율적!
    - 대수확장성: 트리 깊이가 리프 노드 수에 비해 매우 느리에 성장하는 것. 깊이 1 증가 -> 인덱스 항목 수는 최대 4배씩 증가

### 4.5.3 인덱스 만드는 방법
- (1) MySQL
    - 클러스터형 인덱스
        - 테이블당 하나 설정
        - primary key 옵션으로 기본키 -> 클러스터형 인덱스 생성
        - 기본키 없이 unique not null 옵션 -> 클러스터형 인덱스
    - 세컨더리 인덱스
        - create index... 명령어 -> 세컨더리 인덱스
        - 하나의 인덱스만 생성한다면 그냥 클러스터형 만드는 게 더 낫다
        - 세컨더리는 보조 인덱스 -> 여러 개의 필드 값 기반으로 쿼리를 많이 보낼 때 생성해야 하는 인덱스
            - ex. age, name, email 등 다양한 필드 기반으로 쿼리 보낼 때 세컨더리 인덱스를 사용 

- (2) MongoDB
    - 도큐먼트를 만들면 자동으로 ObjectID 형성되고, 해당 키가 기본키롤 설정됨
    - 부가적으로 세컨더리키도 설정해서 기본키와 세컨더리키를 같이 쓰는 복합 인덱스 설정 가능

### 4.5.4 인덱스 최적화 기법
- (1) 인덱스는 비용이다
    - 인덱스 리스트 -> 컬렉션 순으로 탐색
    - 컬렉션 수정 시 인덱스도 수정
    - 쿼리에 있는 필드에 인덱스를 무작정 다 설정하는 게 답은 아님
    - 컬렉션에서 가져와야 할 양이 많을수록 인덱스 사용은 비효율적

- (2) 항상 테스팅하라
    - 인덱스 최적화 기법은 서비스 특징에 따라 달라짐
        - 서비스에서 사용하는 객체의 깊이, 테이블의 양 등이 다름 -> 항상 테스팅!
    - explain() 통해 인덱스 만들고 쿼리 보낸 후 테스팅하며 걸리는 시간을 최소화할 것

    ```MySQL
    EXPLAIN
    SELECT * FROM table1
    JOIN table2 ON table1.c1 = table2.c1
    ```

- (3) 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다
    - 인덱스 생성에는 순서가 있고, 생성 순서에 따라 인덱스 성능이 달라짐
    - 같음, 정렬, 다중 값, 카디널리티 순으로 생성~!
        - ㄱ. == 또는 equal
        - ㄴ. 정렬에 쓰는 필드 
        - ㄷ. 다중값 출력해야 하는 필드. 즉 < 또는  > 쿼리를 쓰는 필드라면 나중에 인덱스 만들 것
        - ㄹ. 카디널리티(유니크한 값의 정도) 높은 순으로 인덱스 생성
            - ex. age와 email 중 어느 것이 더 유니크할까? 즉 카디널리티가 높을까? -> email