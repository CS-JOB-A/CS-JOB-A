# Section11 - CPU 스케줄링

1. CPU 스케줄링 개요
(1) CPU 스케줄링: 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것

(2) 프로세스 우선순위
- 우선순위가 높은 프로세스: 빨리 처리해야 하는 프로세스 -> ex. 입출력 작업이 많은 프로세스
- 프로세스는 실행 상태 - 대기 상태를 반복하며 실행
    - 입출력 집중 프로세스: 입출력 작업이 많은 프로세스
        - 입출력을 위한 대기 상태에 더 많이 머무름
    - CPU 집중 프로세스: CPU 작업(복잡한 수학 연산, 컴파일, 그래픽 처리 작업) 많은 프로세스
        - 실행 상태에 더 많이 머무름
    - 입출력 집중과 CPU 집중 프로세스가 동시에 CPU 자원 요구하는 상황 -> 입출력 집중 프로세스를 최대한 빨리 실행시켜 입출력장치를 끊임없이 작동시키고,
    CPU 집중 프로세스에 집중적으로 CPU를 할당하는 게 효율적
    - 모든 프로세스가 CPU를 차례대로 돌아가며 사용하는 것보단 각각의 상황에 맞게 CPU를 배분! -> "우선순위" 부여

(3) 스케줄링 큐
- 운영체제가 프로세스들에게 '줄' 서서 기다릴 것을 요구하는데, 이때 스케줄링 큐를 통해 '줄'을 구현하고 관리.
- 메모리로 적재되고 싶은 프로세스들을 Queue에 삽입하여 줄을 세움(FIFO)
- 준비 큐: CPU를 이용하고 싶은 프로세스들이 서는 줄
- 대기 큐: 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄
- 무조건 큐 순서대로 실행되는 것만도 아닌 게, 우선순위에 따라 실행 순서가 조금 달라짐 

(4) 선점형과 비선점형 스케줄링
- 선점형 스케줄링: 어느 하나의 프로세스가 자원 사용을 독점할 수 없는 스케줄링 방식
    - 더 급한 프로세스가 언제든 끼어들어 사용할 수 있음 -> 특정 프로세스의 자원 독점을 막고 고른 분배 가능하지만, 문맥 교환 과정에서 오버헤드 발생 가능성 있음
- 비선점형 스케줄링: 하나의 프로세스가 자원 사용을 독점할 수 있는 스케줄링 방식
    - 문맥 교환 횟수가 비교적 적기에 오버헤드 발생 가능성은 낮지만, 특정 프로세스가 자원 사용 중이라면 무작정 기다려야만 함 -> 자원을 고르게 사용할 수 없음

2. CPU 스케줄링 알고리즘

(1) 선입 선처리 스케줄링(FCFS 스케줄링, First Come First Served Scheduling)
- 비선점형 스케줄링 방식
- 단점: 호위 효과(ex. 단 2ms의 실행을 위해, 늦게 왔다는 이유만으로 22ms를 기다림) 

(2) 최단 작업 우선 스케줄링(SJF 스케줄링, Shortest Job First Scheduling)
- 호위 효과를 방지하기 위한 방법 -> CPU 사용 시간이 짧은 간단한 프로세스 우선 실행 
- 기본적으로 비선점형으로 구분되지만, 선점형으로 구현될 수도 있음

(3) 라운드 로빈 스케줄링(Round Robin Scheduling)
- 선입 선처리 스케줄링 + 타임 슬라이스
    - 타임 슬라이스: 각 프로세스가 CPU를 사용할 수 있는 정해진 시간
- 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케줄링

(4) 최소 잔여 시간 우선 스케줄링(SRT, Shortest Remaining Time)
- 최단 작업 우선 스케줄링 + 라운드 로빈 
- 프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스로는 남아있는 작업 시간이 가장 적은 프로세스가 선택됨

(5) 우선 순위 스케줄링(Priority Scheduling)
- 가장 높은 우선순위를 가진 프로세스에 CPU를 할당

(6) 다단계 피드백 큐 스케줄링
- 프로세스들이 큐 사이를 이동할 수 있는 다단계 큐 스케줄링