# 들어가며...
- 동기화 기법 중 뮤텍스 락, 세마포, 모니터(대중적 3가지)
<br>
![alt text](../프로세스%20동기화/image/image-2.png)


# 뮤텍스 락
- 상호 배제를 위한 동기화 도구(자물쇠 역할), 뮤텍스 락
<br>
![alt text](../프로세스%20동기화/image/image-3.png)

- 뮤텍스 락의 단순한 형태 : 전역 변수 하나, 함수 두개
    - 자물쇠 역할 : 프로세스들이 공유하는 전역 변수 lock
    - 임계 구역을 잠그는 역할 : acquire 함수
    - 임계 구역의 잠금을 해제하는 역할 : release 함수
<br>
![alt text](../프로세스%20동기화/image/image-4.png)
- acquire 함수
    - 프로세스가 임계 구역에 진입하기 전에 호출
    - 임계 구역이 잠겨 있다면.. 임계 구역이 열릴 때까지(lock이 false가 될 때까지) 임계 구역을 반복적으로 확인
    - 임계 구역이 열려 있다면... 임계 구역을 잠그기(lock을 true로 바꾸기)

- release 함수
    - 임계 구역에서의 작업이 끝나고 호출
    - 현재 잠기 임계 구역을 열기(lock을 false로 바꾸기)

- 바쁜 대기(busy waiting)
``` java
// 그리 좋은 방식은 아니지만 무한히 대기하면서 반복적으로 임계구역이 열려있는지 확인하는 방법  : 바쁜 대기
while (lock == true) /* 만약 임계 구역이 잠겨 있다면 */
;                    /* 임계 구역이 잠겨 있는지를 반복적으로 확인 */
```

# 세마포
- 좀 더 일반화된 방식의 동기화 도구
- 공유 자원이 여러 개 있는 경우에도 적용 가능(뮤텍스 락은 공유 자원이 하나 있을 때..)
- 세마포의 종류(이진 세마포, 카운팅 세마포) 중 카운팅 세마포를 다룹니다.
<br>

![alt text](../프로세스%20동기화/image/image-5.png)

- 동작 방식 : 임계 구역 앞에서 멈춤 신호를 받으면 잠시 기다리고 / 임계 구역 앞에서 가도 좋다는 신호를 받으면 임계 구역을 진입하는 기차와의 동작 방식과 같아서 세마포라는 이름이 붙었다

- 세마포의 단순한 형태 : 전역 변수 하나, 함수 두개
    - 임계 구역에 진입할 수 있는 프로세스의 개수(사용 가능한 공유 자원의 개수)를 나타내는 <strong>전역 변수 S</strong>
    - 임계구역에 들어가도 좋은지, 기다려야 할지를 알려주는 <strong>wait 함수</strong>
    - 임계구역 앞에서 기다리는 프로세스에 '이제 가도 좋다' 고 신호를 주는 <strong>signal 함수</strong>
    
    <br>

    ``` java
    // 다른 책에서는 wait랑 signal이 아닌 다른 용어로 나오기도 한다
    wait()
    // 임계 구역
    signal()



    wait() {
        while(S<= 0) /* 만일 임계 구역에 진입할 수 있는 프로세스 개수가 0 이하라면 */
        ;           /* 사용할 수 있는 자원이 있는지 반복적으로 확인하고 */
        S--;        /* 임계 구역에 진입할 수 있는 프로세스 개수가 하나 이상이면 S를 1 감소시키고 임계 구역 진입 */
    }

    signal() {
        S++;    /* 임계 구역에서의 작업을 마친 뒤 S를 1 증가시킨다 */
    }
    ```
    <br>

    ![alt text](../프로세스%20동기화/image/image-6.png)

- Busy waiting : 마치 탈의실 문이 열렸는지 / 닫혔는지 반복적으로 확인하는 것과 같다 -> CPU 사이클 낭비

- 해결 방법
    - 사용할 수 있는 자원이 없을 경우 <strong>대기 상태</strong>로 만듧(해당 프로세스의 PCB를 대기 큐에 삽입)
    - 사용할 수 있는 자원이 생겼을 경우 대기 큐의 프로세스를 <strong>준비 상태</strong>로 만듧(해당 프로세스의 PCB를 대기 큐에서 꺼내 준비 큐에 삽입)

- 비지 웨이팅을 해결한 방식의 코드..
![alt text](../프로세스%20동기화/image/image-7.png)

- 하지만 임계구역 앞뒤로 항상 웨이트와 시그널을 명시적으로 호출해줘야 한다는 분편함이 있는데 이른 위해 나온것이 있다?/?? 실수도 할 수 있고 그래서 문제를 발생할 수 있다... 디버깅 하기도 힘드렁


# 모니터
- 그래서 등장한 모니터
- 사용자(개발자)가 다루기에 편한 동기화 도구
![alt text](../프로세스%20동기화/image/image-8.png)
- 상호 배제를 위한 동기화와 실행 순서 제어를 위한 동기화 두가지 동기화 방식을 모두 제공해주는 동기화 도구
    1. 상호 배제를 위한 동기화
    - 인터페이스를 위한 큐
    - 공유 자원에 접근하고자 하는 프로세스를 (인터페이스를 위한) 큐에 삽입
    - 큐에 삽입된 순서대로 (한 번에 프로세스만) 공유 자원 이용
    <br>

    ![alt text](../프로세스%20동기화/image/image-9.png)

    2. 실행 순서 제어를 위한 동기화
    - 조건 변수 이용
    - 프로세스나 스레드의 실행 순서를 제어하기 위해 사용하는 특별한 변수
        - 조건변수.wait() : 대기 상태로 변경, 조건 변수에 대한 큐에 삽입
        - 조건 변수.signal() : wait()으로 대기 상태로 접어든 조건 변수를 실행 상태로 변경
    - 정리
        1. 특정 프로세스가 아직 실행될 조건이 되지 않았을 때에는 wait를 통해 실행을 중단
        2. 특정 프로세스가 실행될 조건이 충족되었을 때에는 signal을 통해 실행을 재개

    ![alt text](../프로세스%20동기화/image/image-10.png)

- 모니터 안에는 하나의 프로세스만이 있을 수 있다
- wait()를 호출했던 프로세스는 signal()을 호출한 프로세스가 모니터를 떠난 뒤에 수행을 재개
- signal()을 호출한 프로세스의 실행을 일시 중단하고 자신이 실행된 뒤 다시 signal()을 호출한 프로세스의 수행을 재개