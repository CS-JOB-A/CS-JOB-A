# 들어가며...
- CPU 스케줄링이란..?
<br>
: 운영체제가 프로세스들에게 공정하고 합리적으로 CPU자원을 배분하는 것
<br>
![alt text](../CPU%20스케줄링/image/image.png)
- 컴퓨터 전체 성능과도 직결되는 아주 중요한 문제이다
- 만약 프로세스들한테 CPU를 제대로 분배를 못하면 꼭 실행돼야 되는 프로세스가 실행이 안되거나 아니면 당장 급하지 않은 프로세스들만 계속해서 실행되는 무질서한 상태가 반복될 수 있다
<br>
- 그렇다면 가장 공정한 CPU 스케줄링? 차례대로 돌아가면서?? NO
- 빨리 처리해야 하는 프로세스가 있기 때문에(= 프로세스마다 우선순위가 다르기 때문) 좋은 방법은 아니다
- 입출력 작업이 많은 프로세스(= 입출력 집중 프로세스)의 우선순위는 CPU 작업이 많은 프로세스(= CPU 집중 프로세스)의 우선순위보다 높다
    - 우선순위가 높은 이유...
    - 입출력 작업이 상대적으로 많은 프로세스(입출력 집중 프로세스)는 CPU 작업이 많은 프로세스(CPU 집중 프로세스)에 비해서 대기상태에 더 많이 머무르게 된다(실행 상태 보다)
    - 대기 상태에 머물게 되면 어차피 CPU를 사용하지 않는다
    - 그래서 입출력 작업이 많은 IO Bound 프로세스 입출력 직중 프로세스에 우선순위를 높여서 빨리 처리를 해버리는게 CPU 작업이 많은 CPU 집중 프로세스한테 조금 더 많이 집중적으로 할당할 수 있게 한다
<br>
![alt text](../CPU%20스케줄링/image/image-1.png)

# 프로세스 우선순위
- 프로세스 우선순위(priority) : 상황에 맞게 프로세스가 요구하는 자원에 맞게 프로세스의 중요도에 맞게 프로세스가 CPU를 이용할 수 있도록 하기 위해서 운영체제가 부여하는 것
<br>
![alt text](../CPU%20스케줄링/image/image-2.png)
- 프로세스 우선순위는 간단한 명령어라든지 아니면 프로그램으로서 확인이 가능하다
<br>
![alt text](../CPU%20스케줄링/image/image-3.png)
- 일부 프로세스 같은 경우에는 일부 우선순위의 경우에 사용자가 직접 설정을 하여 우선순위를 조금 높여서 조금 더 빨리 실행되도록 할 수 있다
- 프로세스 익스플로러 : 윈도우 운영체제에서 시스템을 관찰하기 위해서 아주 유용하게 사용되는 툴 중에 하나
- 스케줄링 Q : 자원을 이용하고 싶어 하는 프로세스들이 서는 줄(스케줄링에서의 큐는 반드시 선입선출 방식일 필요는 없습니다)
<br>
![alt text](../CPU%20스케줄링/image/image-4.png)
    - 준비큐와 대기큐
    ![alt text](../CPU%20스케줄링/image/image-5.png)
    - 준비큐 : CPU를 이용하고자 하는 프로세스들이 서는 줄 / 준비 상태에 접어든 프로세스(언제든지 CPU를 할당받아서 실행할 수 있지만 아직 자신의 차례가 되지 않아서 기다리고 있는 상태)
    - 대기큐 : 입출력 장치를 이용하고 싶은 프로세스들이 서는 줄 / 대기 상태에 접어든 프로세스들이 서는 줄(입출력 작업을 해야 될 게 있어서 지금 당장 CPU를 쓸 필요는 없기 때문에 대기 상태에 접어든 프로세스들이 서는 줄을 의미) / 같은 장치를 요구한 프로세스들은 같은 큐에서 대기
    ![alt text](../CPU%20스케줄링/image/image-6.png)
    - 전체적인 흐름 : 동시에 실행 중인 프로세스가 여러 개가 있다고 가정했을 때 CPU 자원은 한정되어 있기 때문에 이 프로세스들끼기 CPU를 번갈아 가면서 사용해야 한다 -> 프로세스들은 준비 상태로 접어들어서 CPU의 할당을 기다림 ->  준비 상태에 접어든 프로세스 중에서 CPU 차례가 되면 디스패치되서 CPU를 할당받아 실행을 한다(실행 상태) -> 자기의 실행차례가 다 끝나면(타임아웃인터럭트 / 타이머인터럭트) 다시 준비 상태에 집어들게 된다(= 준비큐에 삽입이 된다) -> 다음으로 우선순위가 높은 프로세스가 디스패치 되서 실행상태에 적어든다 -> 쭉 실행을 하다가 입출력 장치를 써야 되는 작업을 하면 이떄부터는 CPU를 쓸 필요가 없기 때문에 대기 큐에 들어가서 대기 상태에 접어들게 되는 흐름...
    <br>
- 프로세스 상태 다이어그램
![alt text](../CPU%20스케줄링/image/image-7.png)
<br>
- 선점형과 비선점형 스케줄링
![alt text](../CPU%20스케줄링/image/image-8.png)
    - 너무 급한 프로세스가 있을때의 해결 경우 2가지
    1. 선점형 스케줄링(preemptive scheduling)
    - 현재 CPU를 사용중인 프로세스로부터 CPU 자원을 빼앗아 다른 프로세스에 할당
    - 프로세스마다 정해진 시간만큼 CPU를 쓰게 하고 정해진 시간을 모두 써서 타임아웃 인터럭트가 발생을 하면 이 운영체제가 이 프로세스로부터 CPU 자원을 딱 뺏어서 다음 차례의 프로세스한테 CPU 자원을 넘겨주는 방식..
    - 어느 한 프로세스의 자원 독점을 막고 프로세스에 골고루 자원을 배분할 수 있다
    - 하지만 그만큼 문맥 교환 과정에서 오버헤드가 발생할 수 있다

    2. 비선점형 스케줄링(non-preemptive scheduling)
    - 현재 CPU를 사용중인 프로세스의 작업이 끝날 때까지 프로세스 기다리기
    - 어떤 프로세스가 한 자원을 점거하고 있다면 이 프로세스가 종료되거나 대기상태에 접어들기 전까지는 그 자원을 쓸 수 없다(기다려야 함)
    