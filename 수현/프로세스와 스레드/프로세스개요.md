# 프로세스
- 보조기억장치에 저장된 프로그램을 실행해라 라고 더블 클릭을 한다던지 이런 식으로 실행을 해서 메모리에 적재하고 실행하는 순간에 그 프로그램은 프로세스가 된다
- 작업 관리자를 열어보면 프로세스를 한 눈에 볼 수 있다

# 프로세스 직접 확인하기
1. 포그라운드 프로세스(foreground process) 
- 사용자가 볼 수 있는 공간에서 실행되는 프로세스
- ex) 일반적으로 실행하는 웹브라우저, 메모장, 워드 프로세스, 게임
2. 백그라운드 프로세스(background process)
- 사용자가 볼 수 없는 공간에서 실행되는 프로세스
- 사용자와 직접 상호작용이 가능한 백그라운드 프로세스
- 사용자와 상호작용하지 않고 그저 정해진 일만 수행하는 프로세스 : 데몬(daemon), 서비스(service)
- 의 두가지 종류가 있다

# 프로세스 제어 블록
- 모든 프로세스는 실행을 위해 CPU가 필요하다
- But, CPU 자원은 한정되어 있다
- 프로세스들은 돌아가며 한정된 시간 만큼만 CPU 이용
    - 자신의 차례에 정해진 시간만큼 CPU 이용
    - 타이머 인터럽트가 발생하면 차례 양보
    - 타이머 인터럽트 : 클럭 실호를 발생시키는 장치에 의해서 추가적으로 발생하는 하드웨어(시간 끝났어를 알려주는 특별한 인터럽트)
    ![alt text](../프로세스와%20스레드/image/image.png)
<br>

- 빠르게 번갈아 수행되는 프로세스들을 관리해야하는데
- 이를 위해 사용하는 자료구조(자료를 저장하는 하나의 형태)가 프로세스 제어 블록 (이하 PCB)
    - 프로세스 관련 정보를 저장하는 자료 구조
    - 마치 상품에 달리 태그와 같은 정보
    - 프로세스 생성 시 커널 영역에 생성, 종료 시 폐기
<br>

- PCB에 담기는 대표적인 정보
    ![alt text](../프로세스와%20스레드/image/image-1.png)
    - 프로세스 ID (= PID)
        - 특정 프로세스를 식별하기 위해 부여하는 고유한 번호(학교의 학번, 회사의 사번)
        ![alt text](../프로세스와%20스레드/image/image-2.png)
    - 레지스터 값
        - 프로세스는 자신의 실행 차례가 오면 이전까지 사용한 레지스터 중간 값을 모두 복원 -> 실행 재게
        - 프로그램 카운터, 스택 포인터...
        - 레지스터 값을 명시하는 이유 :  이전까지 실행했던 내용을 다시 자기 차례가 오면 실행을 재기하기 위해서
    - 프로세스 상태
        - 다음 절(강의)에서 다룰 예정
        - 입출력 장치를 사용하기 위해 기다리는 상태, CPU를 사용하기 위해 기다리는 상태, CPU 이용 중인 상태...
    - CPU 스케줄링 정보
        - 프로세스가 언제, 어떤 순서로 CPU를 할당받을지에 대한 정보
    - 메모리 정보
        - 프로세스가 어느 주소에 저장되어 있는지에 대한 정보
        - 페이지 테이블 정보(지금으로서는 '메모리 주소를 알 수 있는 정보가 담기는구나' 정도로)
    - 사용한 파일과 입출력장치 정보
        - 할당된 입출력장치, 사용 중인(열린) 파일 정보
    - 운영체제마다 차이가 있습니다

# 문맥 교환(context switch)
- 한 프로세스(e.g. 프로세스 A)에서 다른 프로세스(e.g. 프로세스 B)로 실행 순서가 넘어가면?

- 기존에 실행되던 프로세스 A는 지금까지의 <strong>중간 정보</strong>를 백업
    - 프로그램 카운터 등 각종 레지스터 값, 메모리 정보, 열었던 파일, 사용한 입출력 장치 등
    - 이러한 중간 정보 == <strong>문맥(context)</strong>
    - 다름 차례가 왔을 떄 실행을 재개하기 위한 정보
    - <strong>"실행 문맥을 백업해두먼 언제든 해당 프로세스의 실행을 재개할 수 있다"</strong>
<br>

- 뒤이어 실행할 프로세스 B의 문맥을 복구
    - 자연스럽게 실행 중인 프로세스가 바뀜
<br>

- 이처럼 기존의 실행 중인 프로세스 문맥을 백업하고
- 새로운 프로세스 실행을 위해 문맥을 복구하는 과정을
- <strong>문맥 교환(context switching)</strong>이라 된다
    - 여러 프로세스가 끊임없이 빠르게 번갈아 가야 실행되는 원리
![alt text](../프로세스와%20스레드/image/image-3.png)


# 프로세스의 메모리 영역
- 크게 코드 영역(= 테스트 영역), 데이터 영역, 힙 영역, 스택 영역
![alt text](../프로세스와%20스레드/image/image-4.png)
<br>

- 코드 영역(= 텍스트 영역)
    - 실행할 수 있는 코드, 기계어로 이루어진 명령어 저장
    - 데이터가 아닌 CPU가 실행할 명령어가 담기기에 쓰기가 금지된 영역(read-only)
- 데이터 영역
    - 잠깐 썼다가 없앨 데이터가 아닌 프로그램이 실행되는 동안 유지할 데이터 저장
    - e.g. 전역 변수
    - 데이터 영역은 크기가 변하지 않고 고정되어 있는데 그런 점에서 정적할당 영역이라고도 부른다
- 힙 영역
    - 프로그램을 만드는 사용자, 즉 프로그래머가 직접 할당할 수 있는 저장공간
- 스택 영역
    - 데이터가 일시적으로 저장되는 공간
    - (데이터 영역에 담기는 값과는 달리)잠깐 쓰다가 말 값들이 저장되는 공간
    - e.g. 매게 변수, 지역 변수
    - 스택 영역과 힙 영역 두개를 퉁쳐서 동적 할당 영역이라고 부르기도 한다
- 힙 영역과 스택 영역의 크기는 가변적
    - 일반적으로 힙 영역은 낮은 주소 -> 높은 주소로 할당
    - 일반적으로 스택 영역은 높은 주소 -> 낮은 주소로 할당
    - 스택 영역은 힙 영역과 반대되는 방향으로 차올라서 커질 수 없는 공간에 한계가 없도록 하여 할당되는 방향이 반대가 되는 경우가 많다
    ![alt text](../프로세스와%20스레드/image/image-5.png)

